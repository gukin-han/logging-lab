# 실험 결과

- 실험 일시: 2026-02-20
- 부하 조건: 100 VUser, 1분
- API: `GET /api/logs/test` (500건 조회)

---

## 1차 실험: jdbc.resultset (극단적 로그 폭탄)

### TPS 비교표

| Phase | 설정 요약 | TPS | avg (ms) | p95 (ms) | Baseline 대비 |
|-------|----------|-----|----------|----------|---------------|
| 1 | Baseline (로깅 OFF) | **2,485** | 40.18 | 173.37 | 100% |
| 2 | Sync + Text + jdbc.resultset ON | **14.6** | 6,510 | 7,180 | 0.59% |
| 3 | Sync + JSON + jdbc.resultset ON | **13.5** | 7,000 | 7,600 | 0.54% |
| 4 | Async + JSON + jdbc.resultset ON | **18.3** | 5,240 | 5,720 | 0.74% |
| 5 | Async + JSON + jdbc.resultset OFF | **2,429** | 41.12 | 176.62 | 97.7% |

### 관찰

- Phase 1→2: TPS **170배 폭락** (2,485 → 14.6). jdbc.resultset이 요청당 2,500+줄의 로그를 생성하며 I/O가 스레드를 완전히 마비시킴.
- Phase 2→3: TPS 14.6 → 13.5로 차이 미미 (7.5%). I/O 블로킹이 이미 지배적이라 JSON 직렬화 비용이 묻힘.
- Phase 3→4: TPS 13.5 → 18.3으로 35% 회복. 그러나 Baseline 대비 여전히 0.74%. 로그 폭탄이 너무 극단적이라 Async도 버퍼가 금방 차서 한계.
- Phase 4→5: TPS 18.3 → 2,429로 Baseline 97.7% 회복. 원천 차단이 유일한 해결책.

### 한계

Phase 2~4가 모두 TPS 13~18 범위에 몰려있어, **Sync/Async 차이**와 **Text/JSON 차이**가 유의미하게 드러나지 않았다. 로그량이 너무 극단적이어서 모든 설정이 바닥에 깔려버린 것.

---

## 2차 실험: jdbc.sqltiming (적정 수준의 로그)

jdbc.resultset 대신 **jdbc.sqltiming**(요청당 1~2줄)으로 로그량을 줄여, Phase 간 차이가 드러나는지 확인.

### TPS 비교표

| Phase | 설정 요약 | TPS | avg (ms) | p95 (ms) | Baseline 대비 |
|-------|----------|-----|----------|----------|---------------|
| 1 | Baseline (로깅 OFF) | **2,485** | 40.18 | 173.37 | 100% |
| 2b | Sync + Text + jdbc.sqltiming ON | **1,955** | 51.08 | 209.81 | 78.7% |
| 3b | Sync + JSON + jdbc.sqltiming ON | **1,982** | 50.39 | 204.87 | 79.8% |
| 4b | Async + JSON + jdbc.sqltiming ON | **2,004** | 49.83 | 202.52 | 80.6% |

### 관찰

- Phase 1→2b: TPS 2,485 → 1,955로 약 **21% 하락**. 로그가 적당한 수준이면 I/O 부담은 존재하지만 시스템이 붕괴되지는 않음.
- Phase 2b→3b: TPS 1,955 → 1,982로 **차이 없음**. 로그량이 적으면 JSON 직렬화 비용은 무시할 수준.
- Phase 3b→4b: TPS 1,982 → 2,004로 **차이 없음**. 로그량이 적으면 Sync/Async 차이도 드러나지 않음.

### 해석

jdbc.sqltiming 수준의 로그량에서는 Sync/Async, Text/JSON 간 차이가 **오차 범위** 수준이다. 이 실험 조건에서는 세 설정 모두 "적당히 느려지는" 정도로 수렴했다.

---

## 종합 결론

### 데이터가 말하는 것

1. **로그량이 본질이다.** jdbc.resultset(요청당 2,500+줄) → TPS 99.4% 폭락. jdbc.sqltiming(요청당 1~2줄) → TPS 21% 하락. 같은 "로그를 켰다"라도 양에 따라 영향이 하늘과 땅 차이.

2. **Sync/Async, Text/JSON은 극단적 상황에서만 의미 있다.** 로그량이 적정하면 차이가 미미하고, 로그량이 극단적이면 어떤 최적화도 한계가 있다.

3. **원천 차단이 유일한 해결책이다.** Phase 5에서 jdbc.resultset을 OFF 하자 TPS가 97.7% 회복. 비동기 로깅은 보험이지 해결책이 아니다.

### 실무 교훈

> 찍지 말아야 할 로그(jdbc.resultset 등)를 원천 차단하는 것이 1순위이고,
> 비동기 로깅/JSON 포맷 최적화는 그 다음 문제다.
> 환경별 로깅 전략을 Spring Profile로 분리하여 운영 환경에 개발용 설정이 배포되지 않도록 시스템적으로 강제해야 한다.
